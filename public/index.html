<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>KumoWave Lofi</title>
  <!-- Metadata do site -->
  <meta name="description" content="KumoWave Lofi - Relaxe com batidas tranquilas e wallpapers que mudam suavemente. Perfeito para estudar, trabalhar ou simplesmente relaxar.">
  <meta property="og:title" content="KumoWave Lofi">
  <meta property="og:description" content="Player minimalista para curtir streams de lofi hip hop, com wallpapers que mudam suavemente.">
  <meta property="og:type" content="website">
  <meta property="og:image" content="https://i.imgur.com/XYTcQGz.png">
  
  <!-- Favicon usando emoji na URI -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌊</text></svg>">
  
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            primary: '#5D5CDE', secondary: '#A8A7F5',
            dark: { 100: '#3C3C3C', 200: '#2F2F2F', 300: '#242424', 400: '#1A1A1A', 500: '#121212' },
            light: { 100: '#F5F5F5', 200: '#EEEEEE' }
          },
          animation: {
            'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
            'fade-in': 'fadeIn 1.5s ease-in-out forwards',
            'fade-out': 'fadeOut 1.5s ease-in-out forwards',
            'glow': 'glow 2s ease-in-out infinite alternate'
          },
          keyframes: {
            fadeIn: { '0%': { opacity: 0 }, '100%': { opacity: 1 } },
            fadeOut: { '0%': { opacity: 1 }, '100%': { opacity: 0 } },
            glow: { 
              '0%': { textShadow: '0 0 5px rgba(93, 92, 222, 0.5), 0 0 10px rgba(93, 92, 222, 0.3)' }, 
              '100%': { textShadow: '0 0 10px rgba(93, 92, 222, 0.8), 0 0 20px rgba(93, 92, 222, 0.5), 0 0 30px rgba(93, 92, 222, 0.3)' } 
            }
          }
        }
      }
    };
  </script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&family=Quicksand:wght@300;400;500;600&display=swap');
    body { font-family: 'Poppins', sans-serif; overflow: hidden; background-color: #121212; }
    
    /* Logo e branding */
    .logo-text { 
      font-family: 'Quicksand', sans-serif; 
      letter-spacing: 0.05em;
    }
    .animate-glow {
      animation: glow 2s ease-in-out infinite alternate;
    }
    
    /* Wallpaper e efeitos */
    .bg-wallpaper { 
      background-size: cover; 
      background-position: center; 
      background-repeat: no-repeat; 
      position: absolute; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      transition: opacity 1.5s ease-in-out; 
      filter: brightness(0.7); 
    }
    
    /* Efeito de vinheta INTENSIFICADO (mais forte) */
    .vignette-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(
        ellipse at center,
        rgba(0, 0, 0, 0) 0%,
        rgba(0, 0, 0, 0.2) 40%,
        rgba(0, 0, 0, 0.8) 100%
      );
      pointer-events: none;
      z-index: 6;
    }
    
    /* Overlay para textos */
    .text-overlay {
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
    }
    
    /* Credits Bar */
    .credits-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      padding: 10px 15px;
      background-color: rgba(18, 18, 18, 0.7);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      z-index: 40;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.2);
      border-top: 1px solid rgba(60, 60, 60, 0.3);
    }
    
    .dark-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.3); z-index: 5; pointer-events: none; }
    .player-container { backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); background-color: rgba(26, 26, 26, 0.6); }
    .player-btn-side { transition: all 0.2s ease-in-out; color: #FFFFFF; }
    .player-btn-side:hover { transform: scale(1.1); color: #A8A7F5; }
    .player-btn-side:active { transform: scale(0.95); }
    .player-btn-center { transition: all 0.2s ease-in-out; background-color: #FFFFFF; color: #121212; border-radius: 9999px; padding: 0.75rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); }
    .player-btn-center:hover { transform: scale(1.1); background-color: #EEEEEE; }
    .player-btn-center:active { transform: scale(0.95); }
    .player-menu-btn { transition: all 0.2s ease-in-out; color: #FFFFFF; padding: 0.5rem; border-radius: 0.375rem; }
    .player-menu-btn:hover { background-color: rgba(255, 255, 255, 0.1); transform: scale(1.05); }
    input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; height: 5px; background: rgba(255, 255, 255, 0.2); border-radius: 5px; outline: none; cursor: pointer; transition: background 0.3s ease; }
    input[type="range"]:hover { background: rgba(255, 255, 255, 0.3); }
    input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 14px; height: 14px; border-radius: 50%; background: #5D5CDE; cursor: pointer; transition: background 0.3s ease; }
    input[type="range"]:hover::-webkit-slider-thumb { background: #A8A7F5; }
    input[type="range"]::-moz-range-thumb { width: 14px; height: 14px; border-radius: 50%; background: #5D5CDE; cursor: pointer; border: none; transition: background 0.3s ease; }
    input[type="range"]:hover::-moz-range-thumb { background: #A8A7F5; }
    .progress-filled { height: 100%; background: #5D5CDE; border-radius: 5px; position: absolute; top: 0; left: 0; pointer-events: none; transition: width 0.1s linear; }
    .modal-content { background-color: #1A1A1A; }
    .modal-content::-webkit-scrollbar { display: none; }
    .modal-content { -ms-overflow-style: none; scrollbar-width: none; }

    /* Menu Dropdown */
    .menu-dropdown { position: absolute; right: 0; top: 100%; margin-top: 0.5rem; background-color: #2F2F2F; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 50; width: 180px; padding: 0.5rem 0; border: 1px solid #3C3C3C; }
    .menu-item { display: block; width: 100%; padding: 0.5rem 1rem; text-align: left; font-size: 0.875rem; color: #E5E7EB; background: none; border: none; cursor: pointer; }
    .menu-item:hover { background-color: #3C3C3C; color: #FFFFFF; }

    /* Player Menu Dropdown */
    .player-menu-dropdown { position: absolute; bottom: 100%; right: 0; margin-bottom: 0.5rem; background-color: rgba(47, 47, 47, 0.95); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 0.5rem; box-shadow: 0 -2px 10px -3px rgba(0, 0, 0, 0.2); z-index: 60; width: 180px; padding: 0.5rem 0; border: 1px solid #3C3C3C; }
    .player-menu-item { display: block; width: 100%; padding: 0.5rem 1rem; text-align: left; font-size: 0.875rem; color: #E5E7EB; background: none; border: none; cursor: pointer; transition: all 0.2s ease; }
    .player-menu-item:hover { background-color: #3C3C3C; color: #FFFFFF; }
    .player-menu-item i { width: 20px; text-align: center; margin-right: 8px; }

    /* Painel de Volume Mobile - VERTICAL */
    #volumePanel {
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        margin-bottom: 10px;
        background-color: rgba(47, 47, 47, 0.9);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        padding: 15px 10px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        width: 36px;
        height: 120px;
        z-index: 40;
        border: 1px solid #3C3C3C;
        transition: all 0.2s ease-out;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }
    #volumePanel input[type="range"] { 
        height: 100px;
        width: 4px;
        transform: rotate(-90deg);
        transform-origin: center;
    }
    #volumePanel::after {
        content: '';
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-top: 8px solid rgba(47, 47, 47, 0.9);
    }

    /* Footer social icons */
    .social-icon {
        color: #FFFFFF;
        opacity: 0.7;
        transition: all 0.3s ease;
        margin: 0 0.5rem;
    }
    .social-icon:hover {
        opacity: 1;
        color: #5D5CDE;
        transform: translateY(-3px);
    }

    /* Animações Desativadas */
    body.animations-disabled * {
        transition: none !important;
        animation: none !important;
    }
    body.animations-disabled .animate-pulse { animation: none !important; }
    
    /* Esconde painel por padrão, mostra em mobile */
    #volumePanel { display: none; }
    @media (max-width: 767px) {
        #volumeControl { display: none !important; }
    }
    @media (max-width: 767px) {
        #volumePanel.active { display: flex; }
    }

    /* Transition para menu e outros elementos do player */
    .fade-in-up {
        animation: fadeInUp 0.3s ease forwards;
    }
    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
  </style>
</head>
<body class="dark bg-dark-500 text-white">
  <div class="wallpaper-container relative h-screen w-screen">
    <div id="currentWallpaper" class="bg-wallpaper opacity-100 z-0"></div>
    <div id="nextWallpaper" class="bg-wallpaper opacity-0 z-0"></div>
    <div class="dark-overlay z-5"></div>
    <div class="vignette-effect"></div>
  </div>

  <div class="relative z-10 h-screen w-screen flex flex-col justify-between items-center">
    <header class="w-full py-4 px-4 md:px-8 z-20">
      <div class="container mx-auto flex justify-between items-center">
        <div class="logo-container flex items-center">
          <div class="mr-3">
            <div class="w-10 h-10 rounded-lg bg-gradient-to-br from-primary to-secondary flex items-center justify-center shadow-lg">
              <span class="text-xl">🌊</span>
            </div>
          </div>
          <div>
            <h1 class="logo-text text-xl md:text-2xl font-semibold tracking-wider text-white flex items-center text-overlay">
              <span class="text-primary animate-glow">Kumo</span><span>Wave</span>
              <span class="ml-2 text-xs md:text-sm font-light tracking-wide text-secondary opacity-80">Lofi</span>
            </h1>
            <div class="flex items-center mt-0.5">
              <span class="text-xs text-gray-400 tracking-wide">v1.0.5</span>
              <span class="text-xs text-gray-500 mx-2">•</span>
              <span class="text-xs text-gray-400">by <a href="https://github.com/shindozk" target="_blank" class="text-secondary hover:underline">@shindozk</a></span>
            </div>
          </div>
        </div>
        <div class="flex items-center space-x-4">
          <button id="refreshButton" title="Buscar nova stream" class="p-2 rounded-lg text-gray-300 hover:bg-dark-300 hover:text-white transition-colors">
            <i class="fas fa-sync-alt text-xl"></i>
          </button>
          <div class="relative">
             <button id="menuButton" title="Menu" class="p-2 rounded-lg text-gray-300 hover:bg-dark-300 hover:text-white transition-colors">
               <i class="fas fa-bars text-xl"></i>
             </button>
             <div id="menuDropdown" class="menu-dropdown hidden">
                <button id="toggleAnimationsBtn" class="menu-item">Desativar Animações</button>
                <button id="menuApiInfoBtn" class="menu-item">Info API / Stream URL</button>
                <button id="menuAboutBtn" class="menu-item">Sobre KumoWave</button>
                <a href="/stream" target="_blank" class="menu-item">Abrir Stream Puro</a>
             </div>
          </div>
        </div>
      </div>
    </header>

    <div class="now-playing-container text-center p-4 mb-24 max-w-lg mx-auto">
      <div class="bg-dark-400/50 backdrop-blur-lg rounded-xl p-5 shadow-lg border border-gray-700/50">
        <h2 class="text-lg md:text-xl mb-2 font-medium text-gray-200">Now Streaming</h2>
        <div class="flex items-center justify-center space-x-3 mb-4">
           <i id="liveIcon" class="fas fa-podcast text-red-500 text-lg"></i> <p id="sourceInfo" class="text-sm text-gray-300">Carregando...</p>
        </div>
        <h3 id="currentSong" class="text-xl md:text-2xl font-semibold text-primary mb-2 min-h-[3rem] flex items-center justify-center">Buscando Stream...</h3>
        <p id="listeners" class="text-sm text-gray-400">
          <i class="fas fa-headphones mr-2"></i>
          <span id="listenerCount">---</span> listeners
        </p>
      </div>
    </div>

    <div class="player-outer-container w-full fixed bottom-0 left-0 right-0 pb-6 pt-4 px-4 md:px-8 z-30 mb-10">
      <div class="max-w-3xl mx-auto">
        <div class="player-container rounded-2xl shadow-lg p-4 md:p-5 border border-gray-700/50">
          <div class="progress-wrapper relative mb-4 h-1.5 w-full">
             <input type="range" min="0" max="100" value="0" class="absolute inset-0 opacity-0 cursor-pointer z-10" id="progressBarInput" disabled>
             <div class="progress-bar-bg absolute inset-0 bg-gray-600/50 rounded-full h-1.5"></div>
             <div class="progress-filled absolute top-0 left-0 h-1.5 bg-primary rounded-full" id="progressFilled" style="width: 0%"></div>
             <div class="progress-thumb absolute top-1/2 -translate-y-1/2 h-3.5 w-3.5 bg-primary rounded-full shadow -ml-1.5 pointer-events-none hidden" id="progressThumb" style="left: 0%;"></div>
          </div>

          <div class="flex items-center justify-between">
            <div class="flex items-center space-x-3 w-1/3 relative">
              <button class="player-btn-side focus:outline-none" id="volumeBtn" title="Volume">
                <svg id="volumeHighIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6"><path d="M13.5 4.06c0-1.336-1.616-2.005-2.56-1.06l-4.5 4.5H4.508c-1.141 0-2.318.664-2.66 1.905A9.76 9.76 0 0 0 1.5 12c0 .898.121 1.768.348 2.595.341 1.24 1.518 1.905 2.66 1.905H6.44l4.5 4.5c.945.945 2.56.276 2.56-1.06V4.06ZM18.584 5.106a.75.75 0 0 1 1.06 0c3.808 3.807 3.808 9.98 0 13.788a.75.75 0 0 1-1.06-1.06 8.25 8.25 0 0 0 0-11.668.75.75 0 0 1 0-1.06Z" /><path d="M15.932 7.757a.75.75 0 0 1 1.061 0 6 6 0 0 1 0 8.486.75.75 0 0 1-1.06-1.061 4.5 4.5 0 0 0 0-6.364.75.75 0 0 1 0-1.06Z" /></svg>
                <svg id="volumeMuteIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 hidden"><path d="M13.5 4.06c0-1.336-1.616-2.005-2.56-1.06l-4.5 4.5H4.508c-1.141 0-2.318.664-2.66 1.905A9.76 9.76 0 0 0 1.5 12c0 .898.121 1.768.348 2.595.341 1.24 1.518 1.905 2.66 1.905H6.44l4.5 4.5c.945.945 2.56.276 2.56-1.06V4.06ZM17.28 9.72a.75.75 0 0 1 0 1.06l-2.22 2.22 2.22 2.22a.75.75 0 1 1-1.06 1.06l-2.22-2.22-2.22 2.22a.75.75 0 0 1-1.06-1.06l2.22-2.22-2.22-2.22a.75.75 0 1 1 1.06-1.06l2.22 2.22 2.22-2.22a.75.75 0 0 1 1.06 0Z" /></svg>
              </button>
              <div id="volumeControl" class="w-full max-w-[100px] hidden md:block">
                <input type="range" min="0" max="100" value="80" class="volume-slider w-full" id="volumeSliderDesktop">
              </div>
              <div id="volumePanel" class="fade-in-up">
                <input type="range" min="0" max="100" value="80" class="volume-slider" id="volumeSliderMobile" orient="vertical">
              </div>
            </div>

            <div class="flex items-center justify-center space-x-4 md:space-x-6 w-1/3">
              <button class="player-btn-side text-gray-600 dark:text-gray-500 cursor-not-allowed focus:outline-none opacity-50" title="Anterior (desativado)" disabled>
                 <i class="fas fa-backward-step text-xl"></i>
              </button>
              <button class="player-btn-center focus:outline-none" id="playPauseBtn" title="Play">
                <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6"><path fill-rule="evenodd" d="M4.5 5.653c0-1.427 1.529-2.33 2.779-1.643l11.54 6.347c1.295.712 1.295 2.573 0 3.286L7.28 19.99c-1.25.687-2.779-.217-2.779-1.643V5.653Z" clip-rule="evenodd" /></svg>
                <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 hidden"><path fill-rule="evenodd" d="M6.75 5.25a.75.75 0 0 1 .75-.75H9a.75.75 0 0 1 .75.75v13.5a.75.75 0 0 1-.75.75H7.5a.75.75 0 0 1-.75-.75V5.25Zm7.5 0a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 .75.75v13.5a.75.75 0 0 1-.75.75h-1.5a.75.75 0 0 1-.75-.75V5.25Z" clip-rule="evenodd" /></svg>
              </button>
              <button class="player-btn-side text-gray-600 dark:text-gray-500 cursor-not-allowed focus:outline-none opacity-50" title="Próxima (desativado)" disabled>
                 <i class="fas fa-forward-step text-xl"></i>
              </button>
            </div>

            <div class="flex items-center justify-end space-x-4 w-1/3 relative">
              <button id="playerMenuBtn" class="player-menu-btn focus:outline-none" title="Opções do Player">
                <i class="fas fa-ellipsis-vertical text-lg"></i>
              </button>
              <div id="playerMenuDropdown" class="player-menu-dropdown hidden fade-in-up">
                <button id="playerToggleAnimationsBtn" class="player-menu-item"><i class="fas fa-film"></i> Desativar Animações</button>
                <button id="playerApiInfoBtn" class="player-menu-item"><i class="fas fa-code"></i> Info API / Stream</button>
                <button id="playerAboutBtn" class="player-menu-item"><i class="fas fa-info-circle"></i> Sobre KumoWave</button>
                <a href="/stream" target="_blank" class="player-menu-item"><i class="fas fa-external-link-alt"></i> Stream Puro</a>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Barra de créditos no rodapé -->
  <div class="credits-bar">
    <div class="text-xs text-gray-300">
      <span class="font-semibold">KumoWave Lofi v1.0.5</span> • Desenvolvido por <a href="https://github.com/shindozk" target="_blank" class="text-secondary hover:underline">@shindozk</a>
    </div>
    <div class="flex space-x-4">
      <a href="https://github.com/shindozk" target="_blank" class="social-icon" title="GitHub">
        <i class="fab fa-github text-xl"></i>
      </a>
      <a href="https://discord.com/users/shindozk" target="_blank" class="social-icon" title="Discord">
        <i class="fab fa-discord text-xl"></i>
      </a>
    </div>
  </div>

  <audio id="audioPlayer" preload="auto" style="display: none;"></audio>

  <div id="infoModal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center hidden p-4">
    <div class="modal-content rounded-xl max-w-md w-full p-6 md:p-8 shadow-xl max-h-[80vh] overflow-y-auto relative border border-gray-700">
      <button id="closeInfoModal" class="absolute top-3 right-3 text-gray-400 hover:text-white text-2xl leading-none">×</button>
      <h2 class="text-xl font-semibold mb-4 text-gray-100">Sobre KumoWave Lofi</h2>
       <div class="text-gray-300 space-y-3 text-sm md:text-base">
        <p>KumoWave Lofi é um player minimalista para curtir streams de lofi hip hop, principalmente do canal Lofi Everyday no YouTube (e outros canais similares).</p>
        <p>Relaxe com batidas tranquilas e wallpapers que mudam suavemente. Perfeito para estudar, trabalhar ou simplesmente relaxar.</p>
        <div class="pt-4">
          <h3 class="text-lg font-medium mb-2 text-gray-200">Créditos</h3>
          <p class="text-sm">Música: Canais Lofi via YouTube (usando play-dl).</p>
          <p class="text-sm">Tecnologia: Node.js, Express, play-dl, yt-stream, Tailwind CSS, Font Awesome.</p>
          <p class="text-sm">Backgrounds: Lista definida no servidor.</p>
          <p class="text-sm mt-4">Desenvolvido por <a href="https://github.com/shindozk" target="_blank" class="text-secondary hover:underline">ShindoZk (@shindozk)</a></p>
        </div>
      </div>
    </div>
  </div>

  <div id="apiInfoModal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center hidden p-4">
     <div class="modal-content rounded-xl max-w-md w-full p-6 md:p-8 shadow-xl max-h-[80vh] overflow-y-auto relative border border-gray-700">
       <button id="closeApiModal" class="absolute top-3 right-3 text-gray-400 hover:text-white text-2xl leading-none">×</button>
       <h2 class="text-xl font-semibold mb-4 text-gray-100">Informações da API / Stream</h2>
       <div class="text-gray-300 space-y-4 text-sm md:text-base">
         <p>Use a stream de KumoWave Lofi em seus players ou aplicações:</p>
         <p class="font-medium text-gray-200">Endpoint de Stream Direta (Redirecionamento):</p>
         <div class="bg-dark-300 p-3 rounded-lg font-mono text-xs break-all select-all text-gray-300">
             <code id="apiUrlAudioStream"></code>
         </div>
         <p class="text-xs text-gray-400">Este endpoint redireciona para a URL de áudio atual. Ideal para usar em tags `<audio>` ou players que seguem redirecionamentos.</p>

         <p class="font-medium text-gray-200 pt-2">Endpoint de Informações (JSON):</p>
         <div class="bg-dark-300 p-3 rounded-lg font-mono text-xs break-all select-all text-gray-300">
             <code id="apiUrlStreamInfo"></code>
         </div>
          <p class="text-xs text-gray-400">Retorna um JSON com detalhes da stream atual, incluindo `title`, `videoId`, `listeners` e `hasAudioUrl` (indicando se há uma URL de áudio disponível via `/api/audiostream`).</p>

         <div class="pt-2">
           <h3 class="text-lg font-medium mb-2 text-gray-200">Exemplo HTML</h3>
           <div class="bg-dark-300 p-3 rounded-lg overflow-x-auto">
                <pre class="text-xs text-gray-300"><code id="apiExampleHtml"></code></pre>
           </div>
         </div>

          <div class="pt-4">
              <h3 class="text-lg font-medium mb-2 text-gray-200">Stream Atual</h3>
              <p class="text-xs">ID do Vídeo: <span id="modalCurrentVideoId">N/A</span></p>
              <p class="text-xs">Título: <span id="modalCurrentTitle">N/A</span></p>
              <p class="text-xs">Status: <span id="modalCurrentStatus">Carregando...</span></p>
          </div>
       </div>
     </div>
  </div>

  <script>
    // --- Configurações e Estado ---
    const appState = {
      isPlaying: false,
      volume: 80,
      previousVolume: 80,
      isMuted: false,
      currentWallpaperIndex: -1, // Começa inválido até carregar
      wallpaperInterval: null,
      wallpaperList: [], // Lista de URLs dos wallpapers vinda da API
      currentStreamInfo: null, // Guarda { videoId, title, listeners, hasAudioUrl }
      isLoading: false,
      fetchAbortController: null,
      hasAttemptedAutoplay: false,
      animationsEnabled: true, // Novo estado para animações
      isMobileVolumePanelOpen: false // Novo estado para painel mobile
    };

    // --- Elementos DOM ---
    const bodyEl = document.body;
    const currentWallpaperEl = document.getElementById('currentWallpaper');
    const nextWallpaperEl = document.getElementById('nextWallpaper');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const playIcon = document.getElementById('playIcon');
    const pauseIcon = document.getElementById('pauseIcon');
    const volumeSliderDesktop = document.getElementById('volumeSliderDesktop');
    const volumeSliderMobile = document.getElementById('volumeSliderMobile');
    const volumeBtn = document.getElementById('volumeBtn');
    const volumeHighIcon = document.getElementById('volumeHighIcon');
    const volumeMuteIcon = document.getElementById('volumeMuteIcon');
    const volumeControlDesktop = document.getElementById('volumeControl'); // Div do slider desktop
    const volumePanelMobile = document.getElementById('volumePanel'); // Div do painel mobile
    const progressFilled = document.getElementById('progressFilled');
    const progressThumb = document.getElementById('progressThumb');
    const listenerCount = document.getElementById('listenerCount');
    const currentSong = document.getElementById('currentSong');
    const sourceInfo = document.getElementById('sourceInfo');
    const liveIcon = document.getElementById('liveIcon');
    const refreshButton = document.getElementById('refreshButton');
    const audioPlayer = document.getElementById('audioPlayer');

    // Menu
    const menuButton = document.getElementById('menuButton');
    const menuDropdown = document.getElementById('menuDropdown');
    const toggleAnimationsBtn = document.getElementById('toggleAnimationsBtn');
    const menuApiInfoBtn = document.getElementById('menuApiInfoBtn');
    const menuAboutBtn = document.getElementById('menuAboutBtn');

    // Player Menu (Novo)
    const playerMenuBtn = document.getElementById('playerMenuBtn');
    const playerMenuDropdown = document.getElementById('playerMenuDropdown');
    const playerToggleAnimationsBtn = document.getElementById('playerToggleAnimationsBtn');
    const playerApiInfoBtn = document.getElementById('playerApiInfoBtn');
    const playerAboutBtn = document.getElementById('playerAboutBtn');

    // Modais e seus conteúdos
    const infoModal = document.getElementById('infoModal');
    const closeInfoModal = document.getElementById('closeInfoModal');
    const apiInfoModal = document.getElementById('apiInfoModal');
    const closeApiModal = document.getElementById('closeApiModal');
    const apiUrlAudioStream = document.getElementById('apiUrlAudioStream');
    const apiUrlStreamInfo = document.getElementById('apiUrlStreamInfo');
    const apiExampleHtml = document.getElementById('apiExampleHtml');
    const modalCurrentVideoId = document.getElementById('modalCurrentVideoId');
    const modalCurrentTitle = document.getElementById('modalCurrentTitle');
    const modalCurrentStatus = document.getElementById('modalCurrentStatus');


    // --- Funções ---

    // Carrega Stream da API (/api/stream ou /api/refresh)
    async function fetchStreamData(forceRefresh = false) {
       if (appState.isLoading && !forceRefresh) {
          console.log("Fetch já em andamento.");
          return;
       }
       appState.isLoading = true;
       currentSong.textContent = forceRefresh ? "Buscando nova stream..." : "Conectando...";
       sourceInfo.textContent = "Aguarde...";
       listenerCount.textContent = '---';
       liveIcon.classList.remove('text-green-400', 'text-red-500');
       liveIcon.classList.add('text-yellow-500', 'animate-pulse'); // Amarelo durante busca

       if (appState.fetchAbortController) {
          appState.fetchAbortController.abort();
       }
       appState.fetchAbortController = new AbortController();
       const signal = appState.fetchAbortController.signal;

       const apiUrl = forceRefresh ? '/api/refresh' : '/api/stream';
       console.log(`Buscando dados da stream: ${apiUrl}`);

      try {
        const response = await fetch(apiUrl, { signal });
        if (!response.ok) {
          throw new Error(`Erro HTTP ${response.status}: ${response.statusText}`);
        }
        const data = await response.json();
        console.log("Dados recebidos:", data);

        // Ajusta para pegar os dados corretos de /api/stream ou /api/refresh
        let streamInfo = data;
        if (forceRefresh && data.currentStream) {
            streamInfo = data.currentStream; // /refresh retorna dados dentro de currentStream
        }

         // Verifica se streamInfo é válido
         if (!streamInfo || typeof streamInfo.hasAudioUrl === 'undefined') {
             console.error("Resposta da API inválida ou incompleta:", streamInfo);
             throw new Error("Formato de resposta da API inesperado.");
         }

        appState.currentStreamInfo = streamInfo; // Guarda { videoId, title, listeners, hasAudioUrl }
        updateUIWithStreamInfo(streamInfo);

        const hasAudio = streamInfo.hasAudioUrl;
        const audioStreamUrl = `/api/audiostream?t=${Date.now()}`; // Usa caminho relativo sem window.location

        if (!hasAudio) {
          console.warn("API indicou que não há áudio disponível no momento.");
          // Para o player se estava tocando, mas não limpa a src imediatamente
          if (!audioPlayer.paused) {
              pauseAudio();
          }
          // Não define src se não tem áudio
        } else {
            // Verifica se a src precisa ser atualizada
            if (!audioPlayer.src || !audioPlayer.src.includes('/api/audiostream') || audioPlayer.readyState === 0) {
                console.log("Atualizando source do player para:", audioStreamUrl);
                audioPlayer.src = audioStreamUrl;
                audioPlayer.load(); // Importante para carregar a nova URL
            }

             // Lógica de Autoplay / Retomar Reprodução
             if (!appState.hasAttemptedAutoplay) {
                console.log("Tentando autoplay inicial...");
                appState.hasAttemptedAutoplay = true;
                setTimeout(() => playAudio(), 500); // Pequeno delay
             } else if (appState.isPlaying && audioPlayer.paused) {
                 // Se o estado interno diz que deveria tocar, mas o player está pausado
                 console.log("Estado indica 'playing', mas player pausado. Tentando retomar...");
                  setTimeout(() => playAudio(), 500);
             } else if (!appState.isPlaying && !audioPlayer.paused) {
                 // Inconsistência: Player tocando, mas estado é 'paused'. Pausa para sincronizar.
                  console.warn("Inconsistência: Player tocando, mas estado é 'paused'. Pausando player.");
                  pauseAudio();
             }
        }

      } catch (error) {
         if (error.name === 'AbortError') {
            console.log('Busca de stream cancelada.');
         } else {
            console.error('Erro ao buscar ou processar dados da stream:', error);
            currentSong.textContent = "Erro ao conectar";
            sourceInfo.textContent = "Falha na API";
            listenerCount.textContent = "---";
            liveIcon.classList.remove('text-green-400', 'text-yellow-500', 'animate-pulse');
            liveIcon.classList.add('text-red-500');
            appState.currentStreamInfo = { videoId: null, title: "Erro", listeners: 0, hasAudioUrl: false }; // Estado de erro
            updateApiModalInfo(); // Atualiza modal com erro
            if (!audioPlayer.paused) {
                pauseAudio();
            }
            // Tentar novamente após 10 segundos
            setTimeout(() => {
                if (!appState.isLoading) fetchStreamData(false);
            }, 10000);
         }
      } finally {
         appState.isLoading = false;
         appState.fetchAbortController = null;
         // Remove pulso amarelo se não estiver mais carregando E não estiver tocando/verde
         if (!appState.isLoading && !liveIcon.classList.contains('text-green-400')) {
            liveIcon.classList.remove('animate-pulse', 'text-yellow-500');
            if (!appState.currentStreamInfo?.hasAudioUrl) liveIcon.classList.add('text-red-500'); // Garante vermelho se falhou
         }
      }
    }

    // Atualiza a Interface com os dados da Stream
    function updateUIWithStreamInfo(streamInfo) {
        currentSong.textContent = streamInfo.title || "Lofi Stream";
        sourceInfo.textContent = streamInfo.videoId ? `ID: ${streamInfo.videoId}` : "Indisponível";
        listenerCount.textContent = (streamInfo.listeners || '---').toLocaleString();
        updateApiModalInfo(streamInfo); // Atualiza info no modal da API

        const hasAudio = streamInfo && streamInfo.hasAudioUrl;

        liveIcon.classList.remove('text-yellow-500'); // Remove status de carregamento
        if (hasAudio) {
            liveIcon.classList.remove('text-red-500');
            liveIcon.classList.add('text-green-400');
            // Pulso é controlado por play/pause
            if(appState.isPlaying) liveIcon.classList.add('animate-pulse');
            else liveIcon.classList.remove('animate-pulse');
        } else {
             liveIcon.classList.remove('text-green-400', 'animate-pulse');
             liveIcon.classList.add('text-red-500');
             if (streamInfo.title && !streamInfo.title.toLowerCase().includes("erro")) {
                currentSong.textContent = streamInfo.title + " (Áudio Indisponível)";
             } else if (!streamInfo.title) {
                 currentSong.textContent = "Stream Indisponível";
             }
        }
    }

    // Atualiza Infos no Modal da API
    function updateApiModalInfo(streamInfo = appState.currentStreamInfo) {
        const origin = window.location.origin;
        apiUrlAudioStream.textContent = `${origin}/api/audiostream`;
        apiUrlStreamInfo.textContent = `${origin}/api/stream`;
        apiExampleHtml.textContent = `<audio controls src="${origin}/api/audiostream">\n  Seu navegador não suporta áudio HTML5.\n</audio>`;

        if (streamInfo) {
            modalCurrentVideoId.textContent = streamInfo.videoId || 'N/A';
            modalCurrentTitle.textContent = streamInfo.title || 'N/A';
            modalCurrentStatus.textContent = streamInfo.hasAudioUrl ? 'Áudio Disponível' : 'Áudio Indisponível';
            modalCurrentStatus.style.color = streamInfo.hasAudioUrl ? '#4ade80' : '#f87171'; // Verde / Vermelho
        } else {
             modalCurrentVideoId.textContent = 'N/A';
            modalCurrentTitle.textContent = 'N/A';
            modalCurrentStatus.textContent = 'Carregando...';
            modalCurrentStatus.style.color = 'inherit';
        }
    }

    // Funções de Controle de Áudio
    function playAudio() {
         // Verifica se a API indicou que há áudio ANTES de tentar tocar
        if (!appState.currentStreamInfo?.hasAudioUrl) {
            console.warn("Tentativa de play ignorada: API indica que não há áudio disponível.");
            // Forçar um refresh para buscar um novo stream
            fetchStreamData(true);
            return;
        }
         // Garante que a src está definida (caso tenha sido limpa ou não carregada)
         if (!audioPlayer.src || !audioPlayer.src.includes('/api/audiostream')) {
             console.log("Definindo src antes de tocar...");
             audioPlayer.src = `/api/audiostream?t=${Date.now()}`;
             audioPlayer.load();
         }

        if (audioPlayer.paused) {
            console.log("Tentando tocar...");
            audioPlayer.play()
                .then(() => {
                    console.log("Áudio iniciado.");
                    appState.isPlaying = true;
                    updatePlayPauseButton();
                    liveIcon.classList.remove('text-red-500', 'text-yellow-500');
                    liveIcon.classList.add('text-green-400', 'animate-pulse');
                    progressThumb.style.display = 'block'; // Mostra bolinha do progresso
                })
                .catch(error => {
                    console.error("Erro ao tentar tocar áudio:", error);
                    if (error.name === 'NotAllowedError') {
                         console.warn("Autoplay bloqueado. Interação do usuário necessária.");
                         // Poderia exibir uma mensagem na UI
                    } else if (error.name === 'NotSupportedError') {
                        console.error("Formato de áudio não suportado ou URL inválida/expirada.");
                         // Tentar buscar nova stream pode ajudar aqui
                         fetchStreamData(true);
                    }
                    appState.isPlaying = false;
                    updatePlayPauseButton();
                    liveIcon.classList.remove('text-green-400', 'animate-pulse');
                     // Se falhou porque não tinha áudio, deixa vermelho, senão amarelo/erro
                    if (appState.currentStreamInfo?.hasAudioUrl === false) {
                         liveIcon.classList.add('text-red-500');
                    } else {
                        liveIcon.classList.add('text-yellow-500'); // Indica problema
                    }
                     progressThumb.style.display = 'none';
                });
        } else {
            console.log("Áudio já está tocando ou em processo de início.");
            // Garante que o estado e UI estejam corretos se já estiver tocando
             if (!appState.isPlaying) {
                 appState.isPlaying = true;
                 updatePlayPauseButton();
                 liveIcon.classList.add('text-green-400', 'animate-pulse');
                 progressThumb.style.display = 'block';
             }
        }
    }

    function pauseAudio() {
      if (!audioPlayer.paused) {
        audioPlayer.pause();
        console.log("Áudio pausado.");
      }
      // Sempre atualiza o estado e UI, mesmo que já estivesse pausado (para garantir consistência)
      appState.isPlaying = false;
      updatePlayPauseButton();
      liveIcon.classList.remove('animate-pulse');
      progressThumb.style.display = 'none'; // Esconde bolinha
    }

    function togglePlayPause() {
      if (appState.isPlaying) {
        pauseAudio();
      } else {
         playAudio(); // playAudio() já verifica se tem áudio disponível
      }
    }

    function updatePlayPauseButton() {
      if (appState.isPlaying) {
        playIcon.classList.add('hidden');
        pauseIcon.classList.remove('hidden');
        playPauseBtn.setAttribute('title', 'Pause');
      } else {
        playIcon.classList.remove('hidden');
        pauseIcon.classList.add('hidden');
        playPauseBtn.setAttribute('title', 'Play');
      }
    }

    function updateVolume(value, fromSlider = false) {
        value = parseInt(value, 10);
        if (isNaN(value) || value < 0 || value > 100) return; // Validação

        // Se o valor for 0, marca como muted, mas preserva o volume anterior
        if (value === 0) {
            if (!appState.isMuted) { // Só salva o volume anterior se não estava mudo antes
                appState.previousVolume = appState.volume;
            }
            appState.isMuted = true;
        } else {
            appState.isMuted = false;
        }
        appState.volume = value; // Atualiza o volume atual

        audioPlayer.volume = value / 100;
        audioPlayer.muted = appState.isMuted; // Usa o estado de mudo gerenciado

        // Atualiza sliders apenas se a mudança não veio deles mesmos
        if (!fromSlider || fromSlider !== 'desktop') {
            volumeSliderDesktop.value = value;
        }
         if (!fromSlider || fromSlider !== 'mobile') {
            volumeSliderMobile.value = value;
        }


        // Atualiza ícone SVG e title do botão principal
        if (appState.isMuted) {
             volumeHighIcon.classList.add('hidden');
             volumeMuteIcon.classList.remove('hidden');
             volumeBtn.setAttribute('title', 'Tirar Mudo');
        } else {
             volumeMuteIcon.classList.add('hidden');
             volumeHighIcon.classList.remove('hidden');
             volumeBtn.setAttribute('title', 'Volume');
             // Adicionar lógica para volume baixo/médio/alto se tiver ícones
        }
         // Salva no localStorage
         localStorage.setItem('kumowave_volume', appState.volume);
         localStorage.setItem('kumowave_muted', appState.isMuted);
    }

    // --- Funções de Wallpaper (Corrigidas) ---
    function initWallpapers() {
       fetch('/api/wallpapers')
         .then(res => {
             if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
             return res.json();
         })
         .then(data => {
           if (data.wallpapers && data.wallpapers.length > 0) {
             console.log("Wallpapers carregados da API:", data.wallpapers.length);
             appState.wallpaperList = data.wallpapers; // Armazena a lista de URLs puras
             loadInitialWallpaper();
           } else {
              console.warn("API não retornou wallpapers ou lista vazia.");
              // Fallback de wallpapers caso a API não retorne nada
              appState.wallpaperList = [
                "https://iili.io/37mp2x1.jpg",
                "https://iili.io/37pMMjs.jpg",
                "https://iili.io/37pMVZG.jpg",
                "https://iili.io/37pMhG4.png",
                "https://iili.io/37pMj6l.png",
                "https://iili.io/37pMOaS.jpg"
              ];
              loadInitialWallpaper();
           }
         })
         .catch(error => {
           console.error("Erro ao buscar wallpapers da API:", error);
           // Usar wallpapers de fallback em caso de erro
           appState.wallpaperList = [
             "https://iili.io/37mp2x1.jpg",
             "https://iili.io/37pMMjs.jpg",
             "https://iili.io/37pMVZG.jpg",
             "https://iili.io/37pMhG4.png"
           ];
           loadInitialWallpaper();
         });
    }

    function loadInitialWallpaper() {
        if (appState.wallpaperList.length === 0) {
            console.warn("Nenhum wallpaper disponível para carregar.");
            currentWallpaperEl.style.backgroundColor = '#1a1a1a'; // Fundo escuro sólido
            return;
        }
        // Seleciona um índice aleatório
        appState.currentWallpaperIndex = Math.floor(Math.random() * appState.wallpaperList.length);
        const initialWallpaperUrl = appState.wallpaperList[appState.currentWallpaperIndex];

        console.log("Carregando wallpaper inicial:", initialWallpaperUrl);
        // Aplica a URL diretamente, sem adicionar parâmetros
        currentWallpaperEl.style.backgroundImage = `url('${initialWallpaperUrl}')`;
        currentWallpaperEl.style.opacity = 1;
        startWallpaperRotation();
    }

    function startWallpaperRotation() {
         if (appState.wallpaperInterval) { clearInterval(appState.wallpaperInterval); }
         // Rotaciona apenas se as animações estiverem ativadas
         if (appState.animationsEnabled && appState.wallpaperList.length > 1) {
              console.log("Iniciando rotação de wallpapers (5 min).");
              appState.wallpaperInterval = setInterval(rotateWallpaper, 300000); // 5 minutos
         } else {
              console.log("Rotação de wallpapers desativada (animações desligadas ou poucos wallpapers).");
         }
    }

    function rotateWallpaper() {
         if (!appState.animationsEnabled || appState.wallpaperList.length < 2) return; // Verifica novamente

         let nextIndex;
         do {
             nextIndex = Math.floor(Math.random() * appState.wallpaperList.length);
         } while (nextIndex === appState.currentWallpaperIndex); // Evita repetir o mesmo

         const nextWallpaperUrl = appState.wallpaperList[nextIndex];
          console.log("Rotacionando wallpaper para:", nextWallpaperUrl);

         // Usa as classes de fade in/out do Tailwind config
         nextWallpaperEl.style.backgroundImage = `url('${nextWallpaperUrl}')`;
         nextWallpaperEl.style.opacity = 0; // Garante que começa transparente
         nextWallpaperEl.style.zIndex = 1; // Fica abaixo do atual inicialmente

         // Prepara a transição
         currentWallpaperEl.style.zIndex = 2; // Fica na frente
         currentWallpaperEl.classList.remove('animate-fade-in'); // Limpa classes anteriores
         currentWallpaperEl.classList.add('animate-fade-out');   // Aplica fade out

         nextWallpaperEl.style.zIndex = 3; // Passa para a frente
         nextWallpaperEl.classList.remove('animate-fade-out');
         nextWallpaperEl.classList.add('animate-fade-in');    // Aplica fade in
         nextWallpaperEl.style.opacity = 1; // Força opacidade 1 (a animação cuida da transição)


         // Após a animação terminar (1.5s), atualiza o estado
         setTimeout(() => {
           // O wallpaper atual agora é o 'next'
           currentWallpaperEl.style.backgroundImage = nextWallpaperEl.style.backgroundImage;
           currentWallpaperEl.style.opacity = 1;
           currentWallpaperEl.style.zIndex = 0; // Volta ao z-index padrão
           currentWallpaperEl.classList.remove('animate-fade-out'); // Limpa classe

           // Reseta o 'next'
           nextWallpaperEl.style.backgroundImage = '';
           nextWallpaperEl.style.opacity = 0;
           nextWallpaperEl.style.zIndex = 0;
           nextWallpaperEl.classList.remove('animate-fade-in');

           appState.currentWallpaperIndex = nextIndex;
         }, 1500); // Tempo da animação definido no tailwind.config
    }

    // --- Animações ---
    function setAnimationsEnabled(enabled) {
        appState.animationsEnabled = enabled;
        if (enabled) {
            bodyEl.classList.remove('animations-disabled');
            toggleAnimationsBtn.textContent = "Desativar Animações";
            playerToggleAnimationsBtn.innerHTML = '<i class="fas fa-film"></i> Desativar Animações';
            startWallpaperRotation(); // Reinicia rotação se estava parada
             // Garante que o ícone de live volte a pulsar se estiver tocando
             if (appState.isPlaying) liveIcon.classList.add('animate-pulse');
        } else {
            bodyEl.classList.add('animations-disabled');
            toggleAnimationsBtn.textContent = "Ativar Animações";
            playerToggleAnimationsBtn.innerHTML = '<i class="fas fa-film"></i> Ativar Animações';
            if (appState.wallpaperInterval) clearInterval(appState.wallpaperInterval); // Para rotação
            liveIcon.classList.remove('animate-pulse'); // Para pulso do ícone
        }
        localStorage.setItem('kumowave_animationsEnabled', enabled);
    }

    function toggleAnimations() {
        setAnimationsEnabled(!appState.animationsEnabled);
    }

     function loadAnimationSetting() {
         const savedSetting = localStorage.getItem('kumowave_animationsEnabled');
         // Padrão é true se não houver nada salvo
         setAnimationsEnabled(savedSetting === null ? true : (savedSetting === 'true'));
     }

    // --- Menu Player (Novo) ---
    function togglePlayerMenu() {
        playerMenuDropdown.classList.toggle('hidden');
        // Close volume panel if open
        if (appState.isMobileVolumePanelOpen) {
            volumePanelMobile.classList.remove('active');
            appState.isMobileVolumePanelOpen = false;
        }
    }


    // --- Event Listeners ---
    function setupEventListeners() {
      playPauseBtn.addEventListener('click', togglePlayPause);
      refreshButton.addEventListener('click', () => fetchStreamData(true));

      // Sliders de Volume (Desktop e Mobile)
      volumeSliderDesktop.addEventListener('input', (e) => updateVolume(e.target.value, 'desktop'));
      volumeSliderMobile.addEventListener('input', (e) => updateVolume(e.target.value, 'mobile'));

       // Botão de Volume Principal (Com lógica mobile/desktop)
        volumeBtn.addEventListener('click', () => {
            const isMobile = window.innerWidth < 768; // Define breakpoint mobile

            if (isMobile) {
                if (appState.isMobileVolumePanelOpen) {
                    // Painel está aberto, clique significa MUTE/UNMUTE
                    if (appState.isMuted) {
                        updateVolume(appState.previousVolume || 80); // Tira mudo para volume anterior
                    } else {
                        appState.previousVolume = appState.volume; // Salva antes de mutar
                        updateVolume(0); // Muta
                    }
                    // Fecha o painel após mutar/desmutar
                    volumePanelMobile.classList.remove('active');
                    appState.isMobileVolumePanelOpen = false;
                } else {
                    // Painel está fechado, clique significa ABRIR PAINEL
                    volumePanelMobile.classList.add('active');
                    appState.isMobileVolumePanelOpen = true;
                     // Garante que o valor do slider no painel reflita o volume atual
                     volumeSliderMobile.value = appState.volume;
                }
            } else {
                // Desktop: Clique no botão apenas MUTE/UNMUTE
                if (appState.isMuted) {
                    updateVolume(appState.previousVolume || 80);
                } else {
                    appState.previousVolume = appState.volume;
                    updateVolume(0);
                }
            }
        });

         // Fecha painel de volume mobile se clicar fora dele
         document.addEventListener('click', (event) => {
             if (appState.isMobileVolumePanelOpen &&
                 !volumePanelMobile.contains(event.target) &&
                 !volumeBtn.contains(event.target)) {
                 volumePanelMobile.classList.remove('active');
                 appState.isMobileVolumePanelOpen = false;
             }
             // Fecha menu dropdown se clicar fora
             if (!menuDropdown.classList.contains('hidden') &&
                 !menuDropdown.contains(event.target) &&
                 !menuButton.contains(event.target)) {
                  menuDropdown.classList.add('hidden');
             }
             // Fecha menu do player se clicar fora
             if (!playerMenuDropdown.classList.contains('hidden') &&
                 !playerMenuDropdown.contains(event.target) &&
                 !playerMenuBtn.contains(event.target)) {
                  playerMenuDropdown.classList.add('hidden');
             }
         });


      // Listeners do Player HTML5
      audioPlayer.addEventListener('loadstart', () => console.log("Evento: loadstart"));
      audioPlayer.addEventListener('loadedmetadata', () => console.log("Evento: loadedmetadata"));
      audioPlayer.addEventListener('canplay', () => console.log("Evento: canplay - Áudio pode ser reproduzido"));
      audioPlayer.addEventListener('play', () => {
          console.log("Evento: play (HTML5)");
          // Não força estado aqui, playAudio() cuida disso no 'then'
      });
      audioPlayer.addEventListener('playing', () => {
          console.log("Evento: playing (HTML5) - Reprodução iniciada/retomada.");
          // Garante sincronia se playAudio() falhou em atualizar
          if (!appState.isPlaying) {
               appState.isPlaying = true;
               updatePlayPauseButton();
          }
           // Garante ícone verde e pulsando
           liveIcon.classList.remove('text-red-500', 'text-yellow-500');
           liveIcon.classList.add('text-green-400');
           if (appState.animationsEnabled) liveIcon.classList.add('animate-pulse');
           progressThumb.style.display = 'block'; // Mostra bolinha
      });
      audioPlayer.addEventListener('pause', () => {
        console.log("Evento: pause (HTML5)");
        // Garante sincronia se pauseAudio() falhou
        if (appState.isPlaying) {
             appState.isPlaying = false;
             updatePlayPauseButton();
        }
        liveIcon.classList.remove('animate-pulse');
         progressThumb.style.display = 'none'; // Esconde bolinha
      });
      audioPlayer.addEventListener('ended', () => {
        console.log("Evento: ended (HTML5) - Stream terminou ou foi interrompida. Buscando nova.");
        pauseAudio(); // Garante estado/UI de pausa
        // Tenta buscar uma nova stream automaticamente
        appState.hasAttemptedAutoplay = false; // Permite tentar autoplay na nova stream
        fetchStreamData(true);
      });
       audioPlayer.addEventListener('stalled', () => {
            console.warn("Evento: stalled (HTML5) - Download de dados parado.");
            // Se já estava tocando, tenta buscar nova stream
            if (appState.isPlaying) {
                 console.log("Tentando buscar nova stream devido a stall...");
                 fetchStreamData(true);
            }
       });
      audioPlayer.addEventListener('error', (e) => {
         console.error("Erro no elemento de áudio:", e);
         const error = audioPlayer.error;
         let userMessage = "Erro no áudio.";
         if (error) {
            console.error(`Código: ${error.code}, Mensagem: ${error.message || '(sem mensagem)'}`);
            switch (error.code) {
               case MediaError.MEDIA_ERR_ABORTED: userMessage = "Reprodução abortada."; break; // 1
               case MediaError.MEDIA_ERR_NETWORK: userMessage = "Erro de rede."; break; // 2
               case MediaError.MEDIA_ERR_DECODE: userMessage = "Erro ao decodificar."; break; // 3
               case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: userMessage = "Formato/URL inválido."; break; // 4
               default: userMessage = `Erro desconhecido (cód: ${error.code})`;
            }
         }
         currentSong.textContent = userMessage;
         pauseAudio(); // Garante estado/UI de pausa
         liveIcon.classList.remove('text-green-400', 'animate-pulse');
         liveIcon.classList.add('text-red-500'); // Vermelho = erro grave
         // Tenta buscar um novo stream após um erro, com delay
         console.log("Tentando buscar nova stream após erro em 10s...");
         setTimeout(() => {
             appState.hasAttemptedAutoplay = false;
             fetchStreamData(true)
         }, 10000); // Aumenta delay para dar tempo da rede/API recuperar
      });
      // Atualizar barra de progresso (indica atividade em live stream)
      audioPlayer.addEventListener('timeupdate', () => {
          // Para live streams, currentTime pode não avançar muito ou ser 0
          // Apenas mostra 100% se estiver tocando para indicar atividade
          let progress = (audioPlayer.currentTime > 0 && !audioPlayer.paused && appState.isPlaying) ? 100 : 0;
          progressFilled.style.width = `${progress}%`;
          // Mostra/esconde a bolinha junto com o estado de play
           progressThumb.style.left = `${progress}%`;
           progressThumb.style.display = appState.isPlaying ? 'block' : 'none';
      });

      // Menu Dropdown
      menuButton.addEventListener('click', (e) => {
          e.stopPropagation(); // Evita que o document listener feche imediatamente
          menuDropdown.classList.toggle('hidden');
          if (!playerMenuDropdown.classList.contains('hidden')) {
              playerMenuDropdown.classList.add('hidden');
          }
      });
      
      // Player Menu (Novo)
      playerMenuBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          togglePlayerMenu();
          if (!menuDropdown.classList.contains('hidden')) {
              menuDropdown.classList.add('hidden');
          }
      });

      // Toggle Animations (ambos botões)
      toggleAnimationsBtn.addEventListener('click', toggleAnimations);
      playerToggleAnimationsBtn.addEventListener('click', () => {
          toggleAnimations();
          playerMenuDropdown.classList.add('hidden');
      });
      
      // Botões de API Info (ambos) 
      menuApiInfoBtn.addEventListener('click', () => {
          updateApiModalInfo(); // Garante que info está atualizada antes de abrir
          apiInfoModal.classList.remove('hidden');
          menuDropdown.classList.add('hidden'); // Fecha menu
      });
      playerApiInfoBtn.addEventListener('click', () => {
          updateApiModalInfo();
          apiInfoModal.classList.remove('hidden');
          playerMenuDropdown.classList.add('hidden'); // Fecha menu
      });
      
      // Botões About (ambos)
      menuAboutBtn.addEventListener('click', () => {
           infoModal.classList.remove('hidden');
           menuDropdown.classList.add('hidden'); // Fecha menu
      });
      playerAboutBtn.addEventListener('click', () => {
           infoModal.classList.remove('hidden');
           playerMenuDropdown.classList.add('hidden'); // Fecha menu
      });

      // Listeners dos Modais (Fechar)
      closeInfoModal.addEventListener('click', () => infoModal.classList.add('hidden'));
      closeApiModal.addEventListener('click', () => apiInfoModal.classList.add('hidden'));
      // Fechar modal clicando fora
      infoModal.addEventListener('click', (e) => { if (e.target === infoModal) infoModal.classList.add('hidden'); });
      apiInfoModal.addEventListener('click', (e) => { if (e.target === apiInfoModal) apiInfoModal.classList.add('hidden'); });

    }

    // --- Inicialização ---
    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOM Carregado. Inicializando KumoWave...");

      // Carrega configurações salvas
      loadAnimationSetting();
      // Carregar volume salvo
      const savedVolume = localStorage.getItem('kumowave_volume');
      const savedMuted = localStorage.getItem('kumowave_muted');
      if (savedVolume !== null) updateVolume(parseInt(savedVolume));
      if (savedMuted === 'true') updateVolume(0);

      initWallpapers();       // Carrega wallpapers
      setupEventListeners();  // Configura botões e eventos
      updateVolume(appState.volume); // Define volume inicial
      fetchStreamData();      // Busca a stream inicial e tenta autoplay
      updateApiModalInfo();   // Preenche URLs estáticas no modal da API
      console.log("KumoWave Lofi Pronto.");
    });
  </script>
</body>
</html>